name: pipelines_build
configuration:
  environmentVariables:
    readOnly:
      buildPlaneVersion: 0.0.0-m000
      COMMONS_VERSION: 7.31.6
      CHART_VERSION_OVERRIDE: ''
      e2eImageName: jfpip.jfrog.io/jfrog/pipelines-automation-e2e
      dockerVersion: 20.10.9
      dockerComposeVersion: 1.27.4
      npmRegistry: 'https://entplus.jfrog.io/artifactory/api/npm/npm-virtual'
      repo21: 'https://entplus.jfrog.io'
      rtRegistry: pipelines-docker
      SKIP_STEP_STATUS_UPDATE: 'true'
      templateTarget: pipelines-artifacts/template
      XRAY_ENABLED: 'true'
      XRAY_FAIL_PIPELINES: 'true'
  integrations:
    - name: docker_jfrog_io_reader
    - name: entplus_jfrog_io_docker
    - name: entplus_pipelines
    - name: jfdev_agent
    - name: slack_dev_foundation_alerts
    - name: slack_platform_clean_pipeline
    - name: slack_platform_release_pipeline
steps:
  - name: trigger_controlplane_builds
    type: Bash
    configuration:
      inputResources:
        - name: releasesFile
    execution:
      onStart:
        - echo "kicking off all install builds"
        - add_run_variables will_publish_bi="true"
  - name: automation_e2e_build
    type: Bash
    configuration:
      environmentVariables:
        JFROG_CLI_BUILD_NAME: pipelines-automation-e2e
        JFROG_CLI_BUILD_NUMBER: '${run_id}'
      integrations:
        - name: entplus_deployer
        - name: dockerDotJfrog
      inputResources:
        - name: auto_e2e_gitRepo
      inputSteps:
        - name: trigger_controlplane_builds
    execution:
      onStart:
        - pushd $res_auto_e2e_gitRepo_resourcePath/
        - >-
          add_run_variables RELEASE_VERSION=$( ./normalizeReleaseVersion.sh
          master )
        - pushd automation/e2e
        - 'docker build -t $e2eImageName:$RELEASE_VERSION .'
        - 'jfrog rt docker-push $e2eImageName:$RELEASE_VERSION $rtRegistry'
        - popd
  - name: api_build
    type: Bash
    configuration:
      affinityGroup: api
      integrations:
        - name: entplus_deployer
      inputResources:
        - name: apiGit
        - name: buildPlaneFS_cp
        - name: ootbExtensionsFS_cp
        - name: microRunImage
        - name: microBuildImage
      inputSteps:
        - name: trigger_controlplane_builds
    execution:
      onStart:
        - 'source ${res_apiGit_resourcePath}/build/ci/pipelines_step_setup.sh'
        - stepCommons_load_script build/ci/pipelines_build_npm.sh
        - pushd $res_apiGit_resourcePath
        - >-
          add_run_variables RELEASE_VERSION=$( ./normalizeReleaseVersion.sh
          master )
        - add_run_variables RT_REPO="pipelines-docker-dev-local"
        - pushd services/api
        - on_start
        - add_run_variables BUILD_NUMBER=$JFROG_CLI_BUILD_NUMBER
        - 'export apiImageName="entplus.jfrog.io/${RT_REPO}/jfrog/pipelines-api"'
      onExecute:
        - pushd $res_apiGit_resourcePath/services/api
        - mkdir -p bin
        - echo -n $buildPlaneVersion > ./bin/buildplaneVersion.txt
        - >-
          jfrog rt npm-config --server-id-resolve entplus_deployer
          --repo-resolve ${npmRegistry}
        - >-
          add_run_variables PIPELINES_CORE_VERSION=$(
          $res_apiGit_resourcePath/scripts/getPipelinesCoreVersion.sh master
          "npm-virtual" "$buildPlaneVersion" $RELEASE_VERSION )
        - echo "pipelines-core version is $PIPELINES_CORE_VERSION"
        - |
          if [ -z "$PIPELINES_CORE_VERSION" ]
          then
            echo "Pipelines core version is not set"
            exit 1 
          fi
        - 'echo "Release version is ${RELEASE_VERSION}"'
        - ls -atlh ../
        - >-
          cp -vr
          $res_ootbExtensionsFS_cp_resourcePath/extensions-$buildPlaneVersion.tar.gz
          ./bin/extensions.tar.gz
        - >-
          cp -vr
          $res_buildPlaneFS_cp_resourcePath/buildPlane-x86_64-Ubuntu_18.04-$buildPlaneVersion.deb
          ./bin/buildPlane-x86_64-Ubuntu_18.04.deb
        - >-
          cp -vr
          $res_buildPlaneFS_cp_resourcePath/buildPlane-x86_64-Ubuntu_20.04-$buildPlaneVersion.deb
          ./bin/buildPlane-x86_64-Ubuntu_20.04.deb
        - >-
          cp -vr
          $res_buildPlaneFS_cp_resourcePath/buildPlane-x86_64-CentOS_7-$buildPlaneVersion.rpm
          ./bin/buildPlane-x86_64-CentOS_7.rpm
        - >-
          cp -vr
          $res_buildPlaneFS_cp_resourcePath/buildPlane-x86_64-RHEL_7-$buildPlaneVersion.rpm
          ./bin/buildPlane-x86_64-RHEL_7.rpm
        - >-
          cp -vr
          $res_buildPlaneFS_cp_resourcePath/buildPlane-x86_64-RHEL_8-$buildPlaneVersion.rpm
          ./bin/buildPlane-x86_64-RHEL_8.rpm
        - >-
          cp -vr
          $res_buildPlaneFS_cp_resourcePath/buildPlane-x86_64-WindowsServer_2019-$buildPlaneVersion.tar.gz
          ./bin/buildPlane-x86_64-WindowsServer_2019.tar.gz
        - >-
          cp -vr
          $res_buildPlaneFS_cp_resourcePath/buildPlane-x86_64-MacOS_10.15-$buildPlaneVersion.tar.gz
          ./bin/buildPlane-x86_64-MacOS_10.15.tar.gz
        - >
          RT_SERVER=server \

          RT_URL=$repo21 \

          RT_USER=$int_entplus_deployer_user \

          RT_API_KEY=$int_entplus_deployer_apikey \

          IMG_NAME=$apiImageName \

          PIPELINES_CORE_VERSION=$PIPELINES_CORE_VERSION \

          IMG_TAG=$RELEASE_VERSION \

          MICRO_BUILD_IMAGE=$res_microBuildImage_imageName:$res_microBuildImage_imageTag
          \

          BASE_RUN_IMAGE=$res_microRunImage_imageName:$res_microRunImage_imageTag
          \

          ./buildApi.sh
        - 'jfrog rt docker-push $apiImageName:$RELEASE_VERSION $RT_REPO'
        - jfrog rt build-collect-env
        - jfrog rt build-add-git
        - jfrog rt build-publish
        - >-
          if [ $XRAY_ENABLED = "true" ]; then  jfrog rt build-scan
          --project=pipe --fail=${XRAY_FAIL_PIPELINES}; fi
        - popd
      onFailure:
        - >
          if ! common_isReleaseOrMilestoneOrMasterBranch
          "$(pipeline_gitBranchName)" &&
            gitRepoResourceName="$(pipeline_detectGitResource)" &&
            [[ -n "$gitRepoResourceName" ]]; then
            function __updateDependencyValidationStatus() {
              echo "not doing the dependency validation status update"
            }
            export -f __updateDependencyValidationStatus
          fi

          stepCommons_on_failure
      onSuccess:
        - >
          if ! common_isReleaseOrMilestoneOrMasterBranch
          "$(pipeline_gitBranchName)" &&
            gitRepoResourceName="$(pipeline_detectGitResource)" &&
            [[ -n "$gitRepoResourceName" ]]; then
            function __updateDependencyValidationStatus() {
              echo "not doing the dependency validation status update"
            }
            export -f __updateDependencyValidationStatus
          fi

          stepCommons_on_success
      onComplete:
        - stepCommons_on_complete
  - name: api_test
    type: Bash
    configuration:
      affinityGroup: api
      integrations:
        - name: entplus_deployer
      inputResources:
        - name: apiGit
          trigger: false
      inputSteps:
        - name: api_build
      runtime:
        type: image
        image:
          auto:
            language: node
            versions:
              - 14
    execution:
      onStart:
        - 'source ${res_apiGit_resourcePath}/build/ci/pipelines_step_setup.sh'
        - sudo chmod 1777 /tmp
        - sudo apt-get update --allow-unauthenticated
        - sudo apt-get install -y libpq-dev
        - pushd $res_apiGit_resourcePath/services/api
        - echo "Installing pipelines-core@$PIPELINES_CORE_VERSION"
        - >-
          jfrog rt npm-config --server-id-resolve entplus_deployer
          --repo-resolve npm-virtual
        - jfrog rt npm-install "pipelines-core@$PIPELINES_CORE_VERSION"
        - jfrog rt npm-install
        - npm test -- --coverage
        - cp coverage/lcov.info $shared_workspace/lcov.info
      onFailure:
        - >
          if ! common_isReleaseOrMilestoneOrMasterBranch
          "$(pipeline_gitBranchName)" &&
            gitRepoResourceName="$(pipeline_detectGitResource)" &&
            [[ -n "$gitRepoResourceName" ]]; then
            function __updateDependencyValidationStatus() {
              echo "not doing the dependency validation status update"
            }
            export -f __updateDependencyValidationStatus
          fi

          stepCommons_on_failure
      onSuccess:
        - >
          if ! common_isReleaseOrMilestoneOrMasterBranch
          "$(pipeline_gitBranchName)" &&
            gitRepoResourceName="$(pipeline_detectGitResource)" &&
            [[ -n "$gitRepoResourceName" ]]; then
            function __updateDependencyValidationStatus() {
              echo "not doing the dependency validation status update"
            }
            export -f __updateDependencyValidationStatus
          fi

          stepCommons_on_success
      onComplete:
        - stepCommons_on_complete
  - name: api_sonar_scan
    type: Bash
    configuration:
      affinityGroup: api
      integrations:
        - name: entplus_deployer
        - name: sonar_jfrog_info
      inputResources:
        - name: apiGit
          trigger: false
      inputSteps:
        - name: api_test
      environmentVariables:
        SONAR_PROJECT_KEY: pipelines_api
        SONAR_PROJECT_BASE_DIR: ./services/api/src/
        SONAR_QUALITYGATE_WAIT: 'false'
        RUN_SONAR: 'true'
      runtime:
        type: image
        image:
          custom:
            registry: entplus_deployer
            sourceRepository: docker-staging-local
            name: docker.jfrog.io/sonar-scanner
            tag: '${SONAR_DOCKER_TAG:-latest}'
    execution:
      onStart:
        - 'source ${res_apiGit_resourcePath}/build/ci/pipelines_step_setup.sh'
        - stepCommons_load_script build/ci/pipelines_sonar_npm.sh
        - pushd $res_apiGit_resourcePath/services/api/src
        - mkdir tests
        - mkdir coverage
        - cp $shared_workspace/lcov.info coverage/lcov.info
        - on_start
      onExecute:
        - on_execute
      onFailure:
        - >
          if ! common_isReleaseOrMilestoneOrMasterBranch
          "$(pipeline_gitBranchName)" &&
            gitRepoResourceName="$(pipeline_detectGitResource)" &&
            [[ -n "$gitRepoResourceName" ]]; then
            function __updateDependencyValidationStatus() {
              echo "not doing the dependency validation status update"
            }
            export -f __updateDependencyValidationStatus
          fi

          stepCommons_on_failure
      onSuccess:
        - >
          if ! common_isReleaseOrMilestoneOrMasterBranch
          "$(pipeline_gitBranchName)" &&
            gitRepoResourceName="$(pipeline_detectGitResource)" &&
            [[ -n "$gitRepoResourceName" ]]; then
            function __updateDependencyValidationStatus() {
              echo "not doing the dependency validation status update"
            }
            export -f __updateDependencyValidationStatus
          fi

          stepCommons_on_success
      onComplete:
        - stepCommons_on_complete
  - name: api_clam_scan
    type: Bash
    configuration:
      inputSteps:
        - name: api_build
      inputResources:
        - name: cpGit
          trigger: false
      integrations:
        - name: dockerDotJfrog
      environmentVariables:
        PIPELINES_IMAGE: pipelines-api
        APP_PATH: /opt/jfrog/pipelines
    execution:
      onExecute:
        - pushd $res_cpGit_resourcePath/clamAV
        - >-
          docker-compose -p ${PIPELINES_IMAGE} -f docker-compose.yaml up
          --no-build --exit-code-from clamscanner
        - popd
  - name: inst_build
    type: Bash
    configuration:
      environmentVariables:
        FORCE_RUN: 'true'
      integrations:
        - name: entplus_deployer
      inputResources:
        - name: installerGit
        - name: machineImageJSON_fs
        - name: docker_fs
        - name: dockerCompose_fs
        - name: curl_tar_fs
        - name: curl_rpm_fs
        - name: ootbExtensionsJSONFS
        - name: installerBaseImage
        - name: microBuildImage
      inputSteps:
        - name: trigger_controlplane_builds
    execution:
      onStart:
        - >-
          source
          ${res_installerGit_resourcePath}/build/ci/pipelines_step_setup.sh
        - stepCommons_load_script build/ci/pipelines_build_npm.sh
        - add_run_variables RT_REPO="npm-virtual"
        - add_run_variables DOCKER_REPO="pipelines-docker-dev-local"
        - pushd $res_installerGit_resourcePath/
        - >-
          add_run_variables RELEASE_VERSION=$( ./normalizeReleaseVersion.sh
          master )
        - pushd installer
        - on_start
        - add_run_variables BUILD_NUMBER=$JFROG_CLI_BUILD_NUMBER
        - >-
          export
          installerImageName="entplus.jfrog.io/${DOCKER_REPO}/jfrog/pipelines-installer"
        - 'export nativeBuildName=tar-${JFROG_CLI_BUILD_NAME}'
        - 'debBuildName=deb-${JFROG_CLI_BUILD_NAME}'
        - 'rpmBuildName=rpm-${JFROG_CLI_BUILD_NAME}'
      onExecute:
        - pushd $res_installerGit_resourcePath/installer
        - mkdir -p bin dependencies/x86_64/zip/
        - >-
          tar zxvf ${res_docker_fs_resourcePath}/docker-${dockerVersion}.tgz -C
          dependencies/x86_64/zip/
        - >-
          cp -vr
          $res_dockerCompose_fs_resourcePath/installer/docker/docker-compose-${dockerComposeVersion}
          dependencies/x86_64/bin/
        - >-
          mv dependencies/x86_64/bin/docker-compose-${dockerComposeVersion}
          dependencies/x86_64/bin/docker-compose
        - chmod 555 dependencies/x86_64/bin/docker-compose
        - >-
          mv $res_curl_tar_fs_resourcePath/curl/curl/7.74.0/curl-7.74.0.tar.gz
          dependencies/x86_64/deb/
        - >-
          mv
          $res_curl_rpm_fs_resourcePath/installer/curl/curl-7.29.0-59.el7.x86_64.rpm
          dependencies/x86_64/yum/
        - export PIPELINES_VERSION=$RELEASE_VERSION
        - 'echo "Release version is ${RELEASE_VERSION}"'
        - dockerTag="$RELEASE_VERSION"
        - tarFilename="pipelines-$RELEASE_VERSION.tar.gz"
        - rpmFilename="pipelines-$RELEASE_VERSION.rpm"
        - debFilename="pipelines-$RELEASE_VERSION.deb"
        - >-
          cp -vr
          $res_machineImageJSON_fs_resourcePath/${buildPlaneVersion}-buildplaneImages.json
          ./bin/buildplaneImages.json
        - >-
          cp -vr
          $res_ootbExtensionsJSONFS_resourcePath/${buildPlaneVersion}-ootb-extensions.json
          ./bin/ootb-extensions.json
        - echo $buildPlaneVersion > bin/buildplaneVersion.txt
        - echo $RELEASE_VERSION > bin/controlplaneVersion.txt
        - sudo chmod 1777 /tmp
        - sudo apt-get update --allow-unauthenticated
        - sudo apt-get install -y rsync
        - >
          RT_URL=$repo21 \

          RT_USER=$int_entplus_deployer_user \

          RT_API_KEY=$int_entplus_deployer_apikey \

          RT_REGISTRY=entplus.jfrog.io/${RT_REPO} \

          IMG_NAME=$installerImageName \

          MICRO_BUILD_IMAGE=$res_microBuildImage_imageName:$res_microBuildImage_imageTag
          \

          BASE_RUN_IMAGE=$res_installerBaseImage_imageName:$res_installerBaseImage_imageTag
          \

          ./build.sh
        - echo "Generated Artifacts"
        - ls -atlh bin/
        - echo "Successfully built all artifacts"
        - popd
        - pushd $res_installerGit_resourcePath/installer
        - >-
          jfrog rt docker-push $installerImageName:$dockerTag $DOCKER_REPO
          --build-name=${JFROG_CLI_BUILD_NAME}
          --build-number=${JFROG_CLI_BUILD_NUMBER}
        - >-
          jfrog rt upload bin/$tarFilename
          pipelines-installers/installer/$tarFilename
          --build-name=${nativeBuildName}
          --build-number=${JFROG_CLI_BUILD_NUMBER}
        - >-
          jfrog rt upload bin/$debFilename
          deb-snapshot-local/pool/jfrog-pipelines/$debFilename --deb
          xenial/main/all --build-name=${debBuildName}
          --build-number=${JFROG_CLI_BUILD_NUMBER}
        - >-
          jfrog rt upload bin/$rpmFilename
          yum-snapshot-local/jfrog-pipelines/$rpmFilename
          --build-name=${rpmBuildName} --build-number=${JFROG_CLI_BUILD_NUMBER}
        - >-
          jfrog rt build-collect-env ${JFROG_CLI_BUILD_NAME}
          ${JFROG_CLI_BUILD_NUMBER}
        - >-
          jfrog rt build-collect-env ${nativeBuildName}
          ${JFROG_CLI_BUILD_NUMBER}
        - 'jfrog rt build-collect-env ${debBuildName} ${JFROG_CLI_BUILD_NUMBER}'
        - 'jfrog rt build-collect-env ${rpmBuildName} ${JFROG_CLI_BUILD_NUMBER}'
        - >-
          jfrog rt build-add-git ${JFROG_CLI_BUILD_NAME}
          ${JFROG_CLI_BUILD_NUMBER}
        - 'jfrog rt build-add-git ${nativeBuildName} ${JFROG_CLI_BUILD_NUMBER}'
        - 'jfrog rt build-add-git ${debBuildName} ${JFROG_CLI_BUILD_NUMBER}'
        - 'jfrog rt build-add-git ${rpmBuildName} ${JFROG_CLI_BUILD_NUMBER}'
        - >-
          jfrog rt build-publish ${JFROG_CLI_BUILD_NAME}
          ${JFROG_CLI_BUILD_NUMBER}
        - 'jfrog rt build-publish ${nativeBuildName} ${JFROG_CLI_BUILD_NUMBER}'
        - 'jfrog rt build-publish ${debBuildName} ${JFROG_CLI_BUILD_NUMBER}'
        - 'jfrog rt build-publish ${rpmBuildName} ${JFROG_CLI_BUILD_NUMBER}'
        - >-
          if [ $XRAY_ENABLED = "true" ]; then  jfrog rt build-scan
          --project=pipe --fail=${XRAY_FAIL_PIPELINES} ${JFROG_CLI_BUILD_NAME}
          ${JFROG_CLI_BUILD_NUMBER}; fi
        - >-
          if [ $XRAY_ENABLED = "true" ]; then  jfrog rt build-scan
          --project=pipe --fail=${XRAY_FAIL_PIPELINES} ${debBuildName}
          ${JFROG_CLI_BUILD_NUMBER}; fi
        - >-
          if [ $XRAY_ENABLED = "true" ]; then  jfrog rt build-scan
          --project=pipe --fail=${XRAY_FAIL_PIPELINES} ${rpmBuildName}
          ${JFROG_CLI_BUILD_NUMBER}; fi
        - >-
          if [ $XRAY_ENABLED = "true" ]; then  jfrog rt build-scan
          --project=pipe --fail=${XRAY_FAIL_PIPELINES} ${nativeBuildName}
          ${JFROG_CLI_BUILD_NUMBER}; fi
        - popd
      onFailure:
        - >
          if ! common_isReleaseOrMilestoneOrMasterBranch
          "$(pipeline_gitBranchName)" &&
            gitRepoResourceName="$(pipeline_detectGitResource)" &&
            [[ -n "$gitRepoResourceName" ]]; then
            function __updateDependencyValidationStatus() {
              echo "not doing the dependency validation status update"
            }
            export -f __updateDependencyValidationStatus
          fi

          stepCommons_on_failure
      onSuccess:
        - >
          if ! common_isReleaseOrMilestoneOrMasterBranch
          "$(pipeline_gitBranchName)" &&
            gitRepoResourceName="$(pipeline_detectGitResource)" &&
            [[ -n "$gitRepoResourceName" ]]; then
            function __updateDependencyValidationStatus() {
              echo "not doing the dependency validation status update"
            }
            export -f __updateDependencyValidationStatus
          fi

          stepCommons_on_success
        - echo "Cleaning up stale docker images"
        - docker rmi $(docker images -f "dangling=true" -q) || true
      onComplete:
        - stepCommons_on_complete
  - name: inst_test
    type: Bash
    configuration:
      affinityGroup: installer
      integrations:
        - name: entplus_deployer
      inputResources:
        - name: installerGit
      inputSteps:
        - name: inst_build
      runtime:
        type: image
        image:
          auto:
            language: node
            versions:
              - 14
    execution:
      onStart:
        - >-
          source
          ${res_installerGit_resourcePath}/build/ci/pipelines_step_setup.sh
        - pushd $res_installerGit_resourcePath/installer
        - >-
          jfrog rt npm-config --server-id-resolve entplus_deployer
          --repo-resolve npm-virtual
        - jfrog rt npm-install
        - npm test -- --coverage
        - cp coverage/lcov.info $shared_workspace/lcov.info
      onFailure:
        - >
          if ! common_isReleaseOrMilestoneOrMasterBranch
          "$(pipeline_gitBranchName)" &&
            gitRepoResourceName="$(pipeline_detectGitResource)" &&
            [[ -n "$gitRepoResourceName" ]]; then
            function __updateDependencyValidationStatus() {
              echo "not doing the dependency validation status update"
            }
            export -f __updateDependencyValidationStatus
          fi

          stepCommons_on_failure
      onSuccess:
        - >
          if ! common_isReleaseOrMilestoneOrMasterBranch
          "$(pipeline_gitBranchName)" &&
            gitRepoResourceName="$(pipeline_detectGitResource)" &&
            [[ -n "$gitRepoResourceName" ]]; then
            function __updateDependencyValidationStatus() {
              echo "not doing the dependency validation status update"
            }
            export -f __updateDependencyValidationStatus
          fi

          stepCommons_on_success
      onComplete:
        - stepCommons_on_complete
  - name: inst_sonar_scan
    type: Bash
    configuration:
      affinityGroup: installer
      integrations:
        - name: entplus_deployer
        - name: sonar_jfrog_info
      inputResources:
        - name: installerGit
          trigger: false
      inputSteps:
        - name: inst_test
      environmentVariables:
        SONAR_PROJECT_KEY: pipelines_installer
        SONAR_PROJECT_BASE_DIR: ./installer/
        SONAR_QUALITYGATE_WAIT: 'false'
        RUN_SONAR: 'true'
      runtime:
        type: image
        image:
          custom:
            registry: entplus_deployer
            sourceRepository: docker-staging-local
            name: docker.jfrog.io/sonar-scanner
            tag: '${SONAR_DOCKER_TAG:-latest}'
    execution:
      onStart:
        - >-
          source
          ${res_installerGit_resourcePath}/build/ci/pipelines_step_setup.sh
        - stepCommons_load_script build/ci/pipelines_sonar_npm.sh
        - pushd $res_installerGit_resourcePath/installer
        - mkdir coverage
        - cp $shared_workspace/lcov.info coverage/lcov.info
        - on_start
      onExecute:
        - on_execute
      onFailure:
        - >
          if ! common_isReleaseOrMilestoneOrMasterBranch
          "$(pipeline_gitBranchName)" &&
            gitRepoResourceName="$(pipeline_detectGitResource)" &&
            [[ -n "$gitRepoResourceName" ]]; then
            function __updateDependencyValidationStatus() {
              echo "not doing the dependency validation status update"
            }
            export -f __updateDependencyValidationStatus
          fi

          stepCommons_on_failure
      onSuccess:
        - >
          if ! common_isReleaseOrMilestoneOrMasterBranch
          "$(pipeline_gitBranchName)" &&
            gitRepoResourceName="$(pipeline_detectGitResource)" &&
            [[ -n "$gitRepoResourceName" ]]; then
            function __updateDependencyValidationStatus() {
              echo "not doing the dependency validation status update"
            }
            export -f __updateDependencyValidationStatus
          fi

          stepCommons_on_success
      onComplete:
        - stepCommons_on_complete
  - name: inst_clam_scan
    type: Bash
    configuration:
      inputSteps:
        - name: inst_build
      inputResources:
        - name: cpGit
          trigger: false
      integrations:
        - name: dockerDotJfrog
      environmentVariables:
        PIPELINES_IMAGE: pipelines-installer
        APP_PATH: /opt/jfrog/pipelines
    execution:
      onExecute:
        - pushd $res_cpGit_resourcePath/clamAV
        - >-
          docker-compose -p ${PIPELINES_IMAGE} -f docker-compose.yaml up
          --no-build --exit-code-from clamscanner
        - popd
  - name: template_build
    type: Bash
    configuration:
      affinityGroup: template
      integrations:
        - name: entplus_deployer
      inputResources:
        - name: templateGit
      inputSteps:
        - name: trigger_controlplane_builds
      outputResources:
        - name: templateFS
      runtime:
        type: image
        image:
          auto:
            language: go
            versions:
              - 1.16
    execution:
      onStart:
        - >-
          source
          ${res_templateGit_resourcePath}/build/ci/pipelines_step_setup.sh
        - stepCommons_load_script build/ci/pipelines_build_go.sh
        - env
        - pushd $res_templateGit_resourcePath
        - >-
          add_run_variables RELEASE_VERSION=$( ./normalizeReleaseVersion.sh
          master )
        - pushd template
        - on_start
        - go version
        - 'echo "Release version is ${RELEASE_VERSION}"'
        - make install
        - >-
          curl -sSfL
          https://raw.githubusercontent.com/golangci/golangci-lint/master/install.sh
          | sh -s -- -b $(go env GOPATH)/bin v1.43.0
        - golangci-lint run || true
        - make test
        - make ARGS="-ldflags \"-X main.version='$RELEASE_VERSION'\"" build
        - BIN_FILENAME="pipelines-template-$RELEASE_VERSION"
        - >-
          jfrog rt upload template $templateTarget/$BIN_FILENAME --target-props
          "vcs.branch=master"
        - jfrog rt build-collect-env
        - jfrog rt build-add-git
        - jfrog rt build-publish
        - >-
          if [ $XRAY_ENABLED = "true" ]; then  jfrog rt build-scan
          --project=pipe --fail=${XRAY_FAIL_PIPELINES} ; fi
        - popd
      onFailure:
        - >
          if ! common_isReleaseOrMilestoneOrMasterBranch
          "$(pipeline_gitBranchName)" &&
            gitRepoResourceName="$(pipeline_detectGitResource)" &&
            [[ -n "$gitRepoResourceName" ]]; then
            function __updateDependencyValidationStatus() {
              echo "not doing the dependency validation status update"
            }
            export -f __updateDependencyValidationStatus
          fi

          stepCommons_on_failure
      onSuccess:
        - >
          if ! common_isReleaseOrMilestoneOrMasterBranch
          "$(pipeline_gitBranchName)" &&
            gitRepoResourceName="$(pipeline_detectGitResource)" &&
            [[ -n "$gitRepoResourceName" ]]; then
            function __updateDependencyValidationStatus() {
              echo "not doing the dependency validation status update"
            }
            export -f __updateDependencyValidationStatus
          fi

          stepCommons_on_success
      onComplete:
        - stepCommons_on_complete
  - name: template_sonar_scan
    type: Bash
    configuration:
      affinityGroup: template
      integrations:
        - name: entplus_deployer
        - name: dockerDotJfrog
        - name: sonar_jfrog_info
      inputResources:
        - name: templateGit
          trigger: false
      inputSteps:
        - name: template_build
      environmentVariables:
        SONAR_PROJECT_KEY: pipelines_template
        SONAR_PROJECT_BASE_DIR: ./template/
        SONAR_QUALITYGATE_WAIT: 'false'
        RUN_SONAR: 'true'
      runtime:
        type: image
        image:
          custom:
            registry: entplus_deployer
            sourceRepository: docker-staging-local
            name: docker.jfrog.io/sonar-scanner
            tag: '${SONAR_DOCKER_TAG:-latest}'
    execution:
      onStart:
        - >-
          source
          ${res_templateGit_resourcePath}/build/ci/pipelines_step_setup.sh
        - stepCommons_load_script build/ci/pipelines_sonar_go.sh
        - on_start
      onExecute:
        - on_execute
      onFailure:
        - >
          if ! common_isReleaseOrMilestoneOrMasterBranch
          "$(pipeline_gitBranchName)" &&
            gitRepoResourceName="$(pipeline_detectGitResource)" &&
            [[ -n "$gitRepoResourceName" ]]; then
            function __updateDependencyValidationStatus() {
              echo "not doing the dependency validation status update"
            }
            export -f __updateDependencyValidationStatus
          fi

          stepCommons_on_failure
      onSuccess:
        - >
          if ! common_isReleaseOrMilestoneOrMasterBranch
          "$(pipeline_gitBranchName)" &&
            gitRepoResourceName="$(pipeline_detectGitResource)" &&
            [[ -n "$gitRepoResourceName" ]]; then
            function __updateDependencyValidationStatus() {
              echo "not doing the dependency validation status update"
            }
            export -f __updateDependencyValidationStatus
          fi

          stepCommons_on_success
      onComplete:
        - stepCommons_on_complete
  - name: micro_build
    type: Bash
    configuration:
      affinityGroup: micro
      integrations:
        - name: entplus_deployer
      inputSteps:
        - name: trigger_controlplane_builds
        - name: template_sonar_scan
      inputResources:
        - name: microGit
        - name: ootbExtensionsFS_cp
        - name: templateFS
          trigger: false
        - name: microRunImage
        - name: microBuildImage
    execution:
      onStart:
        - 'source ${res_microGit_resourcePath}/build/ci/pipelines_step_setup.sh'
        - stepCommons_load_script build/ci/pipelines_build_npm.sh
        - pushd $res_microGit_resourcePath
        - >-
          add_run_variables RELEASE_VERSION=$( ./normalizeReleaseVersion.sh
          master )
        - add_run_variables RT_REPO="pipelines-docker-dev-local"
        - pushd micro
        - on_start
        - add_run_variables BUILD_NUMBER=$JFROG_CLI_BUILD_NUMBER
        - >-
          export
          microImageName="entplus.jfrog.io/${RT_REPO}/jfrog/pipelines-micro"
      onExecute:
        - pushd $res_microGit_resourcePath/micro
        - mkdir -p bin
        - >-
          add_run_variables PIPELINES_CORE_VERSION=$(
          ../scripts/getPipelinesCoreVersion.sh master "npm-virtual"
          "$buildPlaneVersion" $RELEASE_VERSION)
        - echo "pipelines-core version is $PIPELINES_CORE_VERSION"
        - |
          if [ -z "$PIPELINES_CORE_VERSION" ]
          then
            echo "Pipelines core version is not set"
            exit 1 
          fi
        - 'echo "Release version is ${RELEASE_VERSION}"'
        - >-
          cp -vr
          $res_ootbExtensionsFS_cp_resourcePath/extensions-$buildPlaneVersion.tar.gz
          bin/extensions.tar.gz
        - >-
          cp -vr
          $res_templateFS_resourcePath/pipelines-template-$RELEASE_VERSION
          bin/pipelines-template
        - chmod +x bin/pipelines-template
        - >
          RT_SERVER=repo21 RT_URL=$repo21 \

          RT_USER=$int_entplus_deployer_user
          RT_API_KEY=$int_entplus_deployer_apikey \

          IMG_NAME=$microImageName
          PIPELINES_CORE_VERSION=$PIPELINES_CORE_VERSION
          IMG_TAG=$RELEASE_VERSION \

          MICRO_BUILD_IMAGE=$res_microBuildImage_imageName:$res_microBuildImage_imageTag
          \

          BASE_RUN_IMAGE=$res_microRunImage_imageName:$res_microRunImage_imageTag
          \

          ./buildMicro.sh
        - 'jfrog rt docker-push $microImageName:$RELEASE_VERSION $RT_REPO'
        - jfrog rt build-publish
        - >-
          if [ $XRAY_ENABLED = "true" ]; then  jfrog rt build-scan --project
          pipe --fail=${XRAY_FAIL_PIPELINES}; fi
        - popd
      onFailure:
        - >
          if ! common_isReleaseOrMilestoneOrMasterBranch
          "$(pipeline_gitBranchName)" &&
            gitRepoResourceName="$(pipeline_detectGitResource)" &&
            [[ -n "$gitRepoResourceName" ]]; then
            function __updateDependencyValidationStatus() {
              echo "not doing the dependency validation status update"
            }
            export -f __updateDependencyValidationStatus
          fi

          stepCommons_on_failure
      onSuccess:
        - >
          if ! common_isReleaseOrMilestoneOrMasterBranch
          "$(pipeline_gitBranchName)" &&
            gitRepoResourceName="$(pipeline_detectGitResource)" &&
            [[ -n "$gitRepoResourceName" ]]; then
            function __updateDependencyValidationStatus() {
              echo "not doing the dependency validation status update"
            }
            export -f __updateDependencyValidationStatus
          fi

          stepCommons_on_success
      onComplete:
        - stepCommons_on_complete
  - name: micro_test
    type: Bash
    configuration:
      affinityGroup: micro
      integrations:
        - name: entplus_deployer
      inputResources:
        - name: microGit
      inputSteps:
        - name: micro_build
      runtime:
        type: image
        image:
          auto:
            language: node
            versions:
              - 14
    execution:
      onStart:
        - 'source ${res_microGit_resourcePath}/build/ci/pipelines_step_setup.sh'
        - stepCommons_load_script build/ci/pipelines_build_npm.sh
        - cd $res_microGit_resourcePath/micro
        - on_start
        - >-
          jfrog rt npm-config --server-id-resolve entplus_deployer
          --repo-resolve npm-virtual
        - echo "Installing pipelines-core@$PIPELINES_CORE_VERSION"
        - jfrog rt npm-install "pipelines-core@$PIPELINES_CORE_VERSION"
        - jfrog rt npm-install
        - npm test -- --coverage
        - cp coverage/lcov.info $shared_workspace/lcov.info
      onFailure:
        - >
          if ! common_isReleaseOrMilestoneOrMasterBranch
          "$(pipeline_gitBranchName)" &&
            gitRepoResourceName="$(pipeline_detectGitResource)" &&
            [[ -n "$gitRepoResourceName" ]]; then
            function __updateDependencyValidationStatus() {
              echo "not doing the dependency validation status update"
            }
            export -f __updateDependencyValidationStatus
          fi

          stepCommons_on_failure
      onSuccess:
        - >
          if ! common_isReleaseOrMilestoneOrMasterBranch
          "$(pipeline_gitBranchName)" &&
            gitRepoResourceName="$(pipeline_detectGitResource)" &&
            [[ -n "$gitRepoResourceName" ]]; then
            function __updateDependencyValidationStatus() {
              echo "not doing the dependency validation status update"
            }
            export -f __updateDependencyValidationStatus
          fi

          stepCommons_on_success
      onComplete:
        - stepCommons_on_complete
  - name: micro_sonar_scan
    type: Bash
    configuration:
      affinityGroup: micro
      integrations:
        - name: entplus_deployer
        - name: sonar_jfrog_info
      inputResources:
        - name: microGit
          trigger: false
      inputSteps:
        - name: micro_test
      environmentVariables:
        SONAR_PROJECT_KEY: pipelines_micro
        SONAR_PROJECT_BASE_DIR: ./micro/
        SONAR_QUALITYGATE_WAIT: 'false'
        RUN_SONAR: 'true'
      runtime:
        type: image
        image:
          custom:
            registry: entplus_deployer
            sourceRepository: docker-staging-local
            name: docker.jfrog.io/sonar-scanner
            tag: '${SONAR_DOCKER_TAG:-latest}'
    execution:
      onStart:
        - 'source ${res_microGit_resourcePath}/build/ci/pipelines_step_setup.sh'
        - stepCommons_load_script build/ci/pipelines_sonar_npm.sh
        - pushd $res_microGit_resourcePath/micro
        - mkdir coverage
        - cp $shared_workspace/lcov.info coverage/lcov.info
        - on_start
      onExecute:
        - on_execute
      onFailure:
        - >
          if ! common_isReleaseOrMilestoneOrMasterBranch
          "$(pipeline_gitBranchName)" &&
            gitRepoResourceName="$(pipeline_detectGitResource)" &&
            [[ -n "$gitRepoResourceName" ]]; then
            function __updateDependencyValidationStatus() {
              echo "not doing the dependency validation status update"
            }
            export -f __updateDependencyValidationStatus
          fi

          stepCommons_on_failure
      onSuccess:
        - >
          if ! common_isReleaseOrMilestoneOrMasterBranch
          "$(pipeline_gitBranchName)" &&
            gitRepoResourceName="$(pipeline_detectGitResource)" &&
            [[ -n "$gitRepoResourceName" ]]; then
            function __updateDependencyValidationStatus() {
              echo "not doing the dependency validation status update"
            }
            export -f __updateDependencyValidationStatus
          fi

          stepCommons_on_success
      onComplete:
        - stepCommons_on_complete
  - name: micro_clam_scan
    type: Bash
    configuration:
      inputSteps:
        - name: micro_build
      inputResources:
        - name: cpGit
          trigger: false
      integrations:
        - name: dockerDotJfrog
      environmentVariables:
        PIPELINES_IMAGE: pipelines-micro
        APP_PATH: /opt/jfrog/pipelines
    execution:
      onExecute:
        - pushd $res_cpGit_resourcePath/clamAV
        - >-
          docker-compose -p ${PIPELINES_IMAGE} -f docker-compose.yaml up
          --no-build --exit-code-from clamscanner
        - popd
  - name: msg
    type: DockerBuild
    configuration:
      affinityGroup: msg
      dockerFileLocation: installer/dependencies/docker/msg
      dockerFileName: Dockerfile
      dockerImageName: 'entplus.jfrog.io/${RT_REPO}/jfrog/pipelines-msg'
      dockerImageTag: '${RELEASE_VERSION}'
      environmentVariables:
        SKIP_DOCKER_RESOURCES_CLEANUP: 'true'
      integrations:
        - name: entplus_deployer
        - name: dockerDotJfrog
      inputResources:
        - name: msgGit
      inputSteps:
        - name: trigger_controlplane_builds
    execution:
      onStart:
        - 'source ${res_msgGit_resourcePath}/build/ci/pipelines_step_setup.sh'
        - pushd $res_msgGit_resourcePath
        - >-
          add_run_variables RELEASE_VERSION=$(./normalizeReleaseVersion.sh
          master)
        - stepCommons_load_script build/ci/pipelines_build_npm.sh
        - add_run_variables RT_REPO="pipelines-docker-dev-local"
        - pushd installer/dependencies/docker/msg
        - on_start
      onFailure:
        - >
          if ! common_isReleaseOrMilestoneOrMasterBranch
          "$(pipeline_gitBranchName)" &&
            gitRepoResourceName="$(pipeline_detectGitResource)" &&
            [[ -n "$gitRepoResourceName" ]]; then
            function __updateDependencyValidationStatus() {
              echo "not doing the dependency validation status update"
            }
            export -f __updateDependencyValidationStatus
          fi

          stepCommons_on_failure
      onSuccess:
        - >
          if ! common_isReleaseOrMilestoneOrMasterBranch
          "$(pipeline_gitBranchName)" &&
            gitRepoResourceName="$(pipeline_detectGitResource)" &&
            [[ -n "$gitRepoResourceName" ]]; then
            function __updateDependencyValidationStatus() {
              echo "not doing the dependency validation status update"
            }
            export -f __updateDependencyValidationStatus
          fi

          stepCommons_on_success
      onComplete:
        - stepCommons_on_complete
  - name: msg_publish
    type: DockerPush
    configuration:
      affinityGroup: msg
      targetRepository: '${RT_REPO}'
      forceXrayScan: '${XRAY_ENABLED}'
      failOnScan: '${XRAY_FAIL_PIPELINES}'
      autoPublishBuildInfo: true
      integrations:
        - name: entplus_deployer
        - name: dockerDotJfrog
      inputSteps:
        - name: msg
      outputResources:
        - name: msgBuildInfo
  - name: msg_clam_scan
    type: Bash
    configuration:
      affinityGroup: msg
      inputSteps:
        - name: msg_publish
      inputResources:
        - name: cpGit
          trigger: false
      integrations:
        - name: dockerDotJfrog
      environmentVariables:
        PIPELINES_IMAGE: pipelines-msg
        APP_PATH: /opt/jfrog/pipelines
    execution:
      onExecute:
        - pushd $res_cpGit_resourcePath/clamAV
        - >-
          docker-compose -p ${PIPELINES_IMAGE} -f docker-compose.yaml up
          --no-build --exit-code-from clamscanner
        - popd
  - name: redis
    type: DockerBuild
    configuration:
      affinityGroup: redis
      dockerFileLocation: installer/dependencies/docker/redis
      dockerFileName: Dockerfile
      dockerImageName: 'entplus.jfrog.io/${RT_REPO}/jfrog/pipelines-redis'
      dockerImageTag: '${RELEASE_VERSION}'
      environmentVariables:
        SKIP_DOCKER_RESOURCES_CLEANUP: 'true'
      integrations:
        - name: entplus_deployer
        - name: dockerDotJfrog
      inputResources:
        - name: redisGit
      inputSteps:
        - name: trigger_controlplane_builds
    execution:
      onStart:
        - 'source ${res_redisGit_resourcePath}/build/ci/pipelines_step_setup.sh'
        - pushd $res_redisGit_resourcePath
        - >-
          add_run_variables RELEASE_VERSION=$(./normalizeReleaseVersion.sh
          master)
        - stepCommons_load_script build/ci/pipelines_build_npm.sh
        - add_run_variables RT_REPO="pipelines-docker-dev-local"
        - pushd installer/dependencies/docker/redis
        - on_start
      onFailure:
        - >
          if ! common_isReleaseOrMilestoneOrMasterBranch
          "$(pipeline_gitBranchName)" &&
            gitRepoResourceName="$(pipeline_detectGitResource)" &&
            [[ -n "$gitRepoResourceName" ]]; then
            function __updateDependencyValidationStatus() {
              echo "not doing the dependency validation status update"
            }
            export -f __updateDependencyValidationStatus
          fi

          stepCommons_on_failure
      onSuccess:
        - >
          if ! common_isReleaseOrMilestoneOrMasterBranch
          "$(pipeline_gitBranchName)" &&
            gitRepoResourceName="$(pipeline_detectGitResource)" &&
            [[ -n "$gitRepoResourceName" ]]; then
            function __updateDependencyValidationStatus() {
              echo "not doing the dependency validation status update"
            }
            export -f __updateDependencyValidationStatus
          fi

          stepCommons_on_success
      onComplete:
        - stepCommons_on_complete
  - name: redis_publish
    type: DockerPush
    configuration:
      affinityGroup: redis
      targetRepository: '${RT_REPO}'
      forceXrayScan: '${XRAY_ENABLED}'
      failOnScan: '${XRAY_FAIL_PIPELINES}'
      autoPublishBuildInfo: true
      integrations:
        - name: entplus_deployer
        - name: dockerDotJfrog
      inputSteps:
        - name: redis
      outputResources:
        - name: redisBuildInfo
  - name: redis_clam_scan
    type: Bash
    configuration:
      affinityGroup: redis
      inputSteps:
        - name: redis_publish
      inputResources:
        - name: cpGit
          trigger: false
      integrations:
        - name: dockerDotJfrog
      environmentVariables:
        PIPELINES_IMAGE: pipelines-redis
        APP_PATH: /opt/jfrog/pipelines
    execution:
      onExecute:
        - pushd $res_cpGit_resourcePath/clamAV
        - >-
          docker-compose -p ${PIPELINES_IMAGE} -f docker-compose.yaml up
          --no-build --exit-code-from clamscanner
        - popd
  - name: postgres
    type: DockerBuild
    configuration:
      affinityGroup: postgres
      dockerFileLocation: installer/dependencies/docker/postgres
      dockerFileName: Dockerfile
      dockerImageName: 'entplus.jfrog.io/${RT_REPO}/jfrog/pipelines-postgres'
      dockerImageTag: '${RELEASE_VERSION}'
      environmentVariables:
        SKIP_DOCKER_RESOURCES_CLEANUP: 'true'
      integrations:
        - name: entplus_deployer
        - name: dockerDotJfrog
      inputResources:
        - name: postgresGit
      inputSteps:
        - name: trigger_controlplane_builds
    execution:
      onStart:
        - >-
          source
          ${res_postgresGit_resourcePath}/build/ci/pipelines_step_setup.sh
        - pushd $res_postgresGit_resourcePath
        - >-
          add_run_variables RELEASE_VERSION=$(./normalizeReleaseVersion.sh
          master)
        - stepCommons_load_script build/ci/pipelines_build_npm.sh
        - add_run_variables RT_REPO="pipelines-docker-dev-local"
        - pushd installer/dependencies/docker/postgres
        - on_start
      onFailure:
        - >
          if ! common_isReleaseOrMilestoneOrMasterBranch
          "$(pipeline_gitBranchName)" &&
            gitRepoResourceName="$(pipeline_detectGitResource)" &&
            [[ -n "$gitRepoResourceName" ]]; then
            function __updateDependencyValidationStatus() {
              echo "not doing the dependency validation status update"
            }
            export -f __updateDependencyValidationStatus
          fi

          stepCommons_on_failure
      onSuccess:
        - >
          if ! common_isReleaseOrMilestoneOrMasterBranch
          "$(pipeline_gitBranchName)" &&
            gitRepoResourceName="$(pipeline_detectGitResource)" &&
            [[ -n "$gitRepoResourceName" ]]; then
            function __updateDependencyValidationStatus() {
              echo "not doing the dependency validation status update"
            }
            export -f __updateDependencyValidationStatus
          fi

          stepCommons_on_success
      onComplete:
        - stepCommons_on_complete
  - name: postgres_publish
    type: DockerPush
    configuration:
      affinityGroup: postgres
      targetRepository: '${RT_REPO}'
      forceXrayScan: '${XRAY_ENABLED}'
      failOnScan: '${XRAY_FAIL_PIPELINES}'
      autoPublishBuildInfo: true
      integrations:
        - name: entplus_deployer
        - name: dockerDotJfrog
      inputSteps:
        - name: postgres
      inputResources:
        - name: postgresGit
      outputResources:
        - name: postgresBuildInfo
  - name: postgres_clam_scan
    type: Bash
    configuration:
      affinityGroup: postgres
      inputSteps:
        - name: postgres_publish
      inputResources:
        - name: cpGit
          trigger: false
      integrations:
        - name: dockerDotJfrog
      environmentVariables:
        PIPELINES_IMAGE: pipelines-postgres
        APP_PATH: /opt/jfrog/pipelines
    execution:
      onExecute:
        - pushd $res_cpGit_resourcePath/clamAV
        - >-
          docker-compose -p ${PIPELINES_IMAGE} -f docker-compose.yaml up
          --no-build --exit-code-from clamscanner
        - popd
  - name: pipelines_router
    type: DockerBuild
    configuration:
      affinityGroup: router
      dockerFileLocation: installer/dependencies/docker/router
      dockerFileName: Dockerfile
      dockerImageName: 'entplus.jfrog.io/${RT_REPO}/jfrog/pipelines-router'
      dockerImageTag: '${RELEASE_VERSION}'
      environmentVariables:
        SKIP_DOCKER_RESOURCES_CLEANUP: 'true'
      integrations:
        - name: entplus_deployer
        - name: dockerDotJfrog
      inputResources:
        - name: routerGit
      inputSteps:
        - name: trigger_controlplane_builds
    execution:
      onStart:
        - 'source ${res_routerGit_resourcePath}/build/ci/pipelines_step_setup.sh'
        - pushd $res_routerGit_resourcePath
        - >-
          add_run_variables RELEASE_VERSION=$(./normalizeReleaseVersion.sh
          master)
        - stepCommons_load_script build/ci/pipelines_build_npm.sh
        - pushd installer/dependencies/docker/router
        - add_run_variables RT_REPO="pipelines-docker-dev-local"
        - on_start
      onFailure:
        - >
          if ! common_isReleaseOrMilestoneOrMasterBranch
          "$(pipeline_gitBranchName)" &&
            gitRepoResourceName="$(pipeline_detectGitResource)" &&
            [[ -n "$gitRepoResourceName" ]]; then
            function __updateDependencyValidationStatus() {
              echo "not doing the dependency validation status update"
            }
            export -f __updateDependencyValidationStatus
          fi

          stepCommons_on_failure
      onSuccess:
        - >
          if ! common_isReleaseOrMilestoneOrMasterBranch
          "$(pipeline_gitBranchName)" &&
            gitRepoResourceName="$(pipeline_detectGitResource)" &&
            [[ -n "$gitRepoResourceName" ]]; then
            function __updateDependencyValidationStatus() {
              echo "not doing the dependency validation status update"
            }
            export -f __updateDependencyValidationStatus
          fi

          stepCommons_on_success
      onComplete:
        - stepCommons_on_complete
  - name: pipelines_router_publish
    type: DockerPush
    configuration:
      affinityGroup: router
      targetRepository: '${RT_REPO}'
      forceXrayScan: false
      autoPublishBuildInfo: true
      integrations:
        - name: entplus_deployer
        - name: dockerDotJfrog
      inputSteps:
        - name: pipelines_router
      inputResources:
        - name: routerGit
      outputResources:
        - name: routerBuildInfo
  - name: pipelines_router_clam_scan
    type: Bash
    configuration:
      affinityGroup: router
      inputSteps:
        - name: pipelines_router_publish
      inputResources:
        - name: cpGit
          trigger: false
      integrations:
        - name: dockerDotJfrog
      environmentVariables:
        PIPELINES_IMAGE: pipelines-router
        APP_PATH: /opt/jfrog/pipelines
    execution:
      onExecute:
        - pushd $res_cpGit_resourcePath/clamAV
        - >-
          docker-compose -p ${PIPELINES_IMAGE} -f docker-compose.yaml up
          --no-build --exit-code-from clamscanner
        - popd
  - name: vault
    type: DockerBuild
    configuration:
      affinityGroup: vault
      dockerFileLocation: installer/dependencies/docker/vault
      dockerFileName: Dockerfile
      dockerImageName: 'entplus.jfrog.io/${RT_REPO}/jfrog/pipelines-vault'
      dockerImageTag: '${RELEASE_VERSION}'
      environmentVariables:
        SKIP_DOCKER_RESOURCES_CLEANUP: 'true'
      integrations:
        - name: entplus_deployer
        - name: dockerDotJfrog
      inputResources:
        - name: vaultGit
      inputSteps:
        - name: trigger_controlplane_builds
    execution:
      onStart:
        - 'source ${res_vaultGit_resourcePath}/build/ci/pipelines_step_setup.sh'
        - pushd $res_vaultGit_resourcePath
        - >-
          add_run_variables RELEASE_VERSION=$(./normalizeReleaseVersion.sh
          master)
        - stepCommons_load_script build/ci/pipelines_build_npm.sh
        - add_run_variables RT_REPO="pipelines-docker-dev-local"
        - pushd installer/dependencies/docker/vault
        - on_start
      onFailure:
        - >
          if ! common_isReleaseOrMilestoneOrMasterBranch
          "$(pipeline_gitBranchName)" &&
            gitRepoResourceName="$(pipeline_detectGitResource)" &&
            [[ -n "$gitRepoResourceName" ]]; then
            function __updateDependencyValidationStatus() {
              echo "not doing the dependency validation status update"
            }
            export -f __updateDependencyValidationStatus
          fi

          stepCommons_on_failure
      onSuccess:
        - >
          if ! common_isReleaseOrMilestoneOrMasterBranch
          "$(pipeline_gitBranchName)" &&
            gitRepoResourceName="$(pipeline_detectGitResource)" &&
            [[ -n "$gitRepoResourceName" ]]; then
            function __updateDependencyValidationStatus() {
              echo "not doing the dependency validation status update"
            }
            export -f __updateDependencyValidationStatus
          fi

          stepCommons_on_success
      onComplete:
        - stepCommons_on_complete
  - name: vault_publish
    type: DockerPush
    configuration:
      affinityGroup: vault
      targetRepository: '${RT_REPO}'
      forceXrayScan: '${XRAY_ENABLED}'
      failOnScan: '${XRAY_FAIL_PIPELINES}'
      autoPublishBuildInfo: true
      integrations:
        - name: entplus_deployer
      inputSteps:
        - name: vault
      outputResources:
        - name: vaultBuildInfo
  - name: vault_clam_scan
    type: Bash
    configuration:
      affinityGroup: vault
      inputSteps:
        - name: vault_publish
      inputResources:
        - name: cpGit
          trigger: false
      integrations:
        - name: dockerDotJfrog
      environmentVariables:
        PIPELINES_IMAGE: pipelines-vault
        APP_PATH: /opt/jfrog/pipelines
    execution:
      onExecute:
        - pushd $res_cpGit_resourcePath/clamAV
        - >-
          docker-compose -p ${PIPELINES_IMAGE} -f docker-compose.yaml up
          --no-build --exit-code-from clamscanner
        - popd
  - name: vault_init
    type: DockerBuild
    configuration:
      affinityGroup: vault_init
      dockerFileLocation: installer/dependencies/docker/vault-init
      dockerFileName: Dockerfile
      dockerImageName: 'entplus.jfrog.io/${RT_REPO}/jfrog/pipelines-vault-init'
      dockerImageTag: '${RELEASE_VERSION}'
      dockerOptions: >-
        --build-arg
        BASE_RUN_IMAGE=$res_microRunImage_imageName:$res_microRunImage_imageTag
      environmentVariables:
        SKIP_DOCKER_RESOURCES_CLEANUP: 'true'
      integrations:
        - name: entplus_deployer
        - name: dockerDotJfrog
      inputResources:
        - name: microRunImage
        - name: vaultInitGit
      inputSteps:
        - name: trigger_controlplane_builds
    execution:
      onStart:
        - >-
          source
          ${res_vaultInitGit_resourcePath}/build/ci/pipelines_step_setup.sh
        - pushd $res_vaultInitGit_resourcePath
        - >-
          add_run_variables RELEASE_VERSION=$(./normalizeReleaseVersion.sh
          master)
        - stepCommons_load_script build/ci/pipelines_build_go.sh
        - add_run_variables RT_REPO="pipelines-docker-dev-local"
        - pushd installer/dependencies/docker/vault-init
        - on_start
      onFailure:
        - >
          if ! common_isReleaseOrMilestoneOrMasterBranch
          "$(pipeline_gitBranchName)" &&
            gitRepoResourceName="$(pipeline_detectGitResource)" &&
            [[ -n "$gitRepoResourceName" ]]; then
            function __updateDependencyValidationStatus() {
              echo "not doing the dependency validation status update"
            }
            export -f __updateDependencyValidationStatus
          fi

          stepCommons_on_failure
      onSuccess:
        - >
          if ! common_isReleaseOrMilestoneOrMasterBranch
          "$(pipeline_gitBranchName)" &&
            gitRepoResourceName="$(pipeline_detectGitResource)" &&
            [[ -n "$gitRepoResourceName" ]]; then
            function __updateDependencyValidationStatus() {
              echo "not doing the dependency validation status update"
            }
            export -f __updateDependencyValidationStatus
          fi

          stepCommons_on_success
      onComplete:
        - stepCommons_on_complete
  - name: vault_init_publish
    type: DockerPush
    configuration:
      affinityGroup: vault_init
      targetRepository: '${RT_REPO}'
      forceXrayScan: '${XRAY_ENABLED}'
      failOnScan: '${XRAY_FAIL_PIPELINES}'
      autoPublishBuildInfo: true
      integrations:
        - name: entplus_deployer
        - name: dockerDotJfrog
      inputSteps:
        - name: vault_init
      inputResources:
        - name: vaultInitGit
      outputResources:
        - name: vaultInitBuildInfo
  - name: vault_init_clam_scan
    type: Bash
    configuration:
      affinityGroup: vault_init
      inputSteps:
        - name: vault_init_publish
      inputResources:
        - name: cpGit
          trigger: false
      integrations:
        - name: dockerDotJfrog
      environmentVariables:
        PIPELINES_IMAGE: pipelines-vault-init
        APP_PATH: /opt/jfrog/pipelines
    execution:
      onExecute:
        - pushd $res_cpGit_resourcePath/clamAV
        - >-
          docker-compose -p ${PIPELINES_IMAGE} -f docker-compose.yaml up
          --no-build --exit-code-from clamscanner
        - popd
  - name: www
    type: DockerBuild
    configuration:
      affinityGroup: www
      dockerFileLocation: services/www
      dockerFileName: Dockerfile
      dockerImageName: 'entplus.jfrog.io/${RT_REPO}/jfrog/pipelines-www'
      dockerImageTag: '${RELEASE_VERSION}'
      dockerOptions: >-
        --build-arg RT_SERVER=entplus_deployer --build-arg RT_URL=${repo21}
        --build-arg RT_USER=${int_entplus_deployer_user} --build-arg
        RT_API_KEY=${int_entplus_deployer_apikey} --build-arg
        BASE_RUN_IMAGE=$res_microRunImage_imageName:$res_microRunImage_imageTag
      environmentVariables:
        SKIP_DOCKER_RESOURCES_CLEANUP: 'true'
      integrations:
        - name: entplus_deployer
        - name: dockerDotJfrog
      inputResources:
        - name: wwwGit
        - name: microRunImage
      inputSteps:
        - name: trigger_controlplane_builds
    execution:
      onStart:
        - 'source ${res_wwwGit_resourcePath}/build/ci/pipelines_step_setup.sh'
        - pushd $res_wwwGit_resourcePath
        - >-
          add_run_variables RELEASE_VERSION=$(./normalizeReleaseVersion.sh
          master)
        - stepCommons_load_script build/ci/pipelines_build_npm.sh
        - add_run_variables RT_REPO="pipelines-docker-dev-local"
        - pushd services/www
        - on_start
        - add_run_variables BUILD_NUMBER=$JFROG_CLI_BUILD_NUMBER
      onFailure:
        - >
          if ! common_isReleaseOrMilestoneOrMasterBranch
          "$(pipeline_gitBranchName)" &&
            gitRepoResourceName="$(pipeline_detectGitResource)" &&
            [[ -n "$gitRepoResourceName" ]]; then
            function __updateDependencyValidationStatus() {
              echo "not doing the dependency validation status update"
            }
            export -f __updateDependencyValidationStatus
          fi

          stepCommons_on_failure
      onSuccess:
        - >
          if ! common_isReleaseOrMilestoneOrMasterBranch
          "$(pipeline_gitBranchName)" &&
            gitRepoResourceName="$(pipeline_detectGitResource)" &&
            [[ -n "$gitRepoResourceName" ]]; then
            function __updateDependencyValidationStatus() {
              echo "not doing the dependency validation status update"
            }
            export -f __updateDependencyValidationStatus
          fi

          stepCommons_on_success
      onComplete:
        - stepCommons_on_complete
  - name: frontend
    type: DockerBuild
    configuration:
      nodePool: pipelines_u20
      affinityGroup: frontend
      dockerFileLocation: services/frontend
      dockerFileName: Dockerfile
      dockerImageName: 'entplus.jfrog.io/${RT_REPO}/jfrog/pipelines-frontend'
      dockerImageTag: '${RELEASE_VERSION}'
      dockerOptions: >-
        --build-arg RT_SERVER=entplus_deployer --build-arg RT_URL=${repo21}
        --build-arg RT_USER=${int_entplus_deployer_user} --build-arg
        RT_API_KEY=${int_entplus_deployer_apikey}
      environmentVariables:
        SKIP_DOCKER_RESOURCES_CLEANUP: 'true'
      integrations:
        - name: entplus_deployer
        - name: dockerDotJfrog
      inputResources:
        - name: frontendGit
      inputSteps:
        - name: trigger_controlplane_builds
    execution:
      onStart:
        - >-
          source
          ${res_frontendGit_resourcePath}/build/ci/pipelines_step_setup.sh
        - pushd $res_frontendGit_resourcePath
        - >-
          add_run_variables RELEASE_VERSION=$(./normalizeReleaseVersion.sh
          master)
        - stepCommons_load_script build/ci/pipelines_build_npm.sh
        - add_run_variables RT_REPO="pipelines-docker-dev-local"
        - pushd services/frontend
        - on_start
      onFailure:
        - >
          if ! common_isReleaseOrMilestoneOrMasterBranch
          "$(pipeline_gitBranchName)" &&
            gitRepoResourceName="$(pipeline_detectGitResource)" &&
            [[ -n "$gitRepoResourceName" ]]; then
            function __updateDependencyValidationStatus() {
              echo "not doing the dependency validation status update"
            }
            export -f __updateDependencyValidationStatus
          fi

          stepCommons_on_failure
      onSuccess:
        - >
          if ! common_isReleaseOrMilestoneOrMasterBranch
          "$(pipeline_gitBranchName)" &&
            gitRepoResourceName="$(pipeline_detectGitResource)" &&
            [[ -n "$gitRepoResourceName" ]]; then
            function __updateDependencyValidationStatus() {
              echo "not doing the dependency validation status update"
            }
            export -f __updateDependencyValidationStatus
          fi

          stepCommons_on_success
      onComplete:
        - stepCommons_on_complete
  - name: frontend_publish
    type: DockerPush
    configuration:
      nodePool: pipelines_u20
      affinityGroup: frontend
      targetRepository: '${RT_REPO}'
      forceXrayScan: '${XRAY_ENABLED}'
      failOnScan: '${XRAY_FAIL_PIPELINES}'
      autoPublishBuildInfo: true
      integrations:
        - name: entplus_deployer
        - name: dockerDotJfrog
      inputSteps:
        - name: frontend
      inputResources:
        - name: frontendGit
      outputResources:
        - name: frontendBuildInfo
  - name: frontend_sonar_scan
    type: Bash
    configuration:
      nodePool: pipelines_u20
      affinityGroup: frontend
      integrations:
        - name: entplus_deployer
        - name: dockerDotJfrog
        - name: sonar_jfrog_info
      inputResources:
        - name: frontendGit
          trigger: false
      inputSteps:
        - name: frontend_publish
      environmentVariables:
        SONAR_PROJECT_KEY: pipelines_frontend
        SONAR_PROJECT_BASE_DIR: ./services/frontend/
        SONAR_QUALITYGATE_WAIT: 'false'
        RUN_SONAR: 'true'
      runtime:
        type: image
        image:
          custom:
            registry: entplus_deployer
            sourceRepository: docker-staging-local
            name: docker.jfrog.io/sonar-scanner
            tag: '${SONAR_DOCKER_TAG:-latest}'
    execution:
      onStart:
        - >-
          source
          ${res_frontendGit_resourcePath}/build/ci/pipelines_step_setup.sh
        - stepCommons_load_script build/ci/pipelines_sonar_npm.sh
        - on_start
      onFailure:
        - >
          if ! common_isReleaseOrMilestoneOrMasterBranch
          "$(pipeline_gitBranchName)" &&
            gitRepoResourceName="$(pipeline_detectGitResource)" &&
            [[ -n "$gitRepoResourceName" ]]; then
            function __updateDependencyValidationStatus() {
              echo "not doing the dependency validation status update"
            }
            export -f __updateDependencyValidationStatus
          fi

          stepCommons_on_failure
      onSuccess:
        - >
          if ! common_isReleaseOrMilestoneOrMasterBranch
          "$(pipeline_gitBranchName)" &&
            gitRepoResourceName="$(pipeline_detectGitResource)" &&
            [[ -n "$gitRepoResourceName" ]]; then
            function __updateDependencyValidationStatus() {
              echo "not doing the dependency validation status update"
            }
            export -f __updateDependencyValidationStatus
          fi

          stepCommons_on_success
      onComplete:
        - stepCommons_on_complete
  - name: www_publish
    type: DockerPush
    configuration:
      affinityGroup: www
      targetRepository: '${RT_REPO}'
      forceXrayScan: '${XRAY_ENABLED}'
      failOnScan: '${XRAY_FAIL_PIPELINES}'
      autoPublishBuildInfo: true
      integrations:
        - name: entplus_deployer
      inputSteps:
        - name: www
      inputResources:
        - name: wwwGit
      outputResources:
        - name: wwwBuildInfo
  - name: www_sonar_scan
    type: Bash
    configuration:
      integrations:
        - name: entplus_deployer
        - name: sonar_jfrog_info
      inputResources:
        - name: wwwGit
          trigger: false
        - name: wwwBuildInfo
      environmentVariables:
        SONAR_PROJECT_KEY: pipelines_www
        SONAR_PROJECT_BASE_DIR: ./services/www/src/
        SONAR_QUALITYGATE_WAIT: 'false'
        RUN_SONAR: 'true'
      runtime:
        type: image
        image:
          custom:
            registry: entplus_deployer
            sourceRepository: docker-staging-local
            name: docker.jfrog.io/sonar-scanner
            tag: '${SONAR_DOCKER_TAG:-latest}'
    execution:
      onStart:
        - 'source ${res_wwwGit_resourcePath}/build/ci/pipelines_step_setup.sh'
        - stepCommons_load_script build/ci/pipelines_sonar_npm.sh
        - on_start
      onFailure:
        - >
          if ! common_isReleaseOrMilestoneOrMasterBranch
          "$(pipeline_gitBranchName)" &&
            gitRepoResourceName="$(pipeline_detectGitResource)" &&
            [[ -n "$gitRepoResourceName" ]]; then
            function __updateDependencyValidationStatus() {
              echo "not doing the dependency validation status update"
            }
            export -f __updateDependencyValidationStatus
          fi

          stepCommons_on_failure
      onSuccess:
        - >
          if ! common_isReleaseOrMilestoneOrMasterBranch
          "$(pipeline_gitBranchName)" &&
            gitRepoResourceName="$(pipeline_detectGitResource)" &&
            [[ -n "$gitRepoResourceName" ]]; then
            function __updateDependencyValidationStatus() {
              echo "not doing the dependency validation status update"
            }
            export -f __updateDependencyValidationStatus
          fi

          stepCommons_on_success
      onComplete:
        - stepCommons_on_complete
  - name: www_clam_scan
    type: Bash
    configuration:
      inputSteps:
        - name: www_publish
      inputResources:
        - name: cpGit
          trigger: false
      integrations:
        - name: dockerDotJfrog
      environmentVariables:
        PIPELINES_IMAGE: pipelines-www
        APP_PATH: /opt/jfrog/pipelines
    execution:
      onExecute:
        - pushd $res_cpGit_resourcePath/clamAV
        - >-
          docker-compose -p ${PIPELINES_IMAGE} -f docker-compose.yaml up
          --no-build --exit-code-from clamscanner
        - popd
  - name: build_helm_chart
    type: Bash
    configuration:
      chronological: true
      integrations:
        - name: pipelines_release_notifications
      inputSteps:
        - name: trigger_controlplane_builds
      inputResources:
        - name: cpGit
          trigger: false
      outputResources:
        - name: helm_build_wh
    execution:
      onStart:
        - 'pushd ${res_cpGit_resourcePath}'
        - >-
          add_run_variables RELEASE_VERSION=$(./normalizeReleaseVersion.sh
          master)
      onExecute:
        - >-
          jsonPayload="{\"PRODUCT_VERSION\":\"$RELEASE_VERSION\",
          \"INSTALLER_COMMON_VERSION\":\"$COMMONS_VERSION\",
          \"PRODUCT_NAME\":\"pipelines\",
          \"INSTALLER_COMMON_REPO\":\"libs-releases\" }"
        - |
          if [[ master = milestone* || master = release* ]]
          then
            set_payload helm_build_wh "$jsonPayload"
            send_notification pipelines_release_notifications --text "triggered build of helm chart version 10${RELEASE_VERSION}"
          fi
      onFailure:
        - export res_helm_build_wh_skipWebHook=true
  - name: trigger_post_release
    type: Bash
    configuration:
      inputSteps:
        - name: api_clam_scan
        - name: api_sonar_scan
        - name: inst_clam_scan
        - name: inst_sonar_scan
        - name: micro_clam_scan
        - name: micro_sonar_scan
        - name: www_clam_scan
        - name: frontend_sonar_scan
        - name: www_sonar_scan
        - name: msg_clam_scan
        - name: postgres_clam_scan
        - name: redis_clam_scan
        - name: pipelines_router_clam_scan
        - name: vault_clam_scan
        - name: vault_init_clam_scan
      integrations:
        - name: entplus_deployer
        - name: pipelines_release_notifications
      inputResources:
        - name: cpGit
          trigger: false
        - name: vaultBuildInfo
        - name: redisBuildInfo
        - name: vaultInitBuildInfo
        - name: postgresBuildInfo
        - name: msgBuildInfo
      outputResources:
        - name: pipe_rc_wh
    execution:
      onStart:
        - echo "trigger rc_pipeline"
      onSuccess:
        - |
          if [[ -n $will_publish_bi  ]]
          then
            if [[ master = milestone* || master = release* ]]
            then
              set_payload pipe_rc_wh "{\"build_number\":\"$BUILD_NUMBER\",\"step_name\":\"$step_name\",\"version\":\"$RELEASE_VERSION\"}"
              send_notification pipelines_release_notifications --text "release $RELEASE_VERSION has been built successfully with BuildPlane version ${buildPlaneVersion} "
            fi
          fi
  - name: create_snapshot_branch
    type: Bash
    configuration:
      inputSteps:
        - name: api_clam_scan
        - name: inst_clam_scan
        - name: micro_clam_scan
        - name: www_clam_scan
        - name: frontend_sonar_scan
        - name: msg_clam_scan
        - name: postgres_clam_scan
        - name: redis_clam_scan
        - name: pipelines_router_clam_scan
        - name: vault_clam_scan
        - name: vault_init_clam_scan
      integrations:
        - name: entArt
        - name: cpIncomingWebhook
        - name: dockerDotJfrog
      inputResources:
        - name: cpGit
          trigger: true
      outputResources:
        - name: branchSnapshotBag
      environmentVariables:
        PIPELINES_IMAGE_PREFIX: pipelines-
        RT_REPO: pipelines-docker-dev-local
        DEFAULT_VERSION:
          default: 0.0.0-m000
          description: >-
            If branch snapshot image is not present for any services, we will
            pull images from 0.0.0-m000(master branch) by default. User can
            change it to any version
    execution:
      onStart:
        - 'source ${res_cpGit_resourcePath}/build/ci/pipelines_step_setup.sh'
        - stepCommons_load_script build/ci/pipelines_build_docker.sh
        - add_run_variables RT_REPO="pipelines-docker-dev-local"
        - >-
          export IMAGE_NAMES="www frontend api micro vault router postgres
          installer msg redis vault-init"
        - 'IMAGE_PREFIX="entplus.jfrog.io/${RT_REPO}/jfrog"'
        - >-
          if [[ "master" == release* ]] || [[ "master" == milestone* ]] || [[
          "master" == preRelease* ]] ;  then exit 0; fi
        - pushd $res_cpGit_resourcePath
        - on_start
        - NORMALIZED_VERSION=$(./normalizeReleaseVersion.sh master)
        - 'BRANCH_SNAPSHOT_VERSION=${NORMALIZED_VERSION:6}-${run_number}'
        - 'echo "Snapshot version will be ${BRANCH_SNAPSHOT_VERSION}"'
        - |
          for image in ${IMAGE_NAMES}; do
            if [[ $(jfrog rt s "${RT_REPO}/jfrog/${PIPELINES_IMAGE_PREFIX}${image}/${NORMALIZED_VERSION}*" | jq length) > 0 ]]; then
              jfrog rt docker-promote --source-tag ${NORMALIZED_VERSION} --target-tag ${BRANCH_SNAPSHOT_VERSION} --copy=true jfrog/${PIPELINES_IMAGE_PREFIX}${image} pipelines-docker-dev-local pipelines-docker-dev-local
            else
              jfrog rt docker-promote --source-tag ${DEFAULT_VERSION} --target-tag ${BRANCH_SNAPSHOT_VERSION} --copy=true jfrog/${PIPELINES_IMAGE_PREFIX}${image} pipelines-docker-dev-local pipelines-docker-dev-local
            fi
          done
        - >-
          write_output branchSnapshotBag
          "snapshotVersion=$BRANCH_SNAPSHOT_VERSION"
        - >-
          committer=$(node automation/tests/committerLoginExtractor.js
          $res_cpGit_lastAuthorEmail)
        - branchName=$res_cpGit_branchName
        - write_output branchSnapshotBag "committer=$committer"
        - write_output branchSnapshotBag "branchName=$branchName"
        - |
          echo "Checking if commit $res_cpGit_commitSha exists"
          if [ "$(git cat-file -t $res_cpGit_commitSha)" != "commit" ]; then
            write_output branchSnapshotBag "onlyAutomationChange=false"
            exit 0
          fi
        - >
          echo "Checking if commit $res_cpGit_beforeCommitSha exists"

          if [ "$(git cat-file -t $res_cpGit_beforeCommitSha)" != "commit" ];
          then
            write_output branchSnapshotBag "onlyAutomationChange=false"
            exit 0
          fi
        - >
          if [ $(git diff --name-only $res_cpGit_beforeCommitSha
          $res_cpGit_commitSha | grep -v "automation/tests/") ]; then
            echo "something other than automation folder has changed"
            write_output branchSnapshotBag "onlyAutomationChange=false"
          else
            echo "only automation folder changed"
            write_output branchSnapshotBag "onlyAutomationChange=true"
          fi
      onComplete:
        - stepCommons_on_complete
      onFailure:
        - >-
          echo "Images are missing for this branch build! Trigger pipelines to
          build"
        - >
          if ! common_isReleaseOrMilestoneOrMasterBranch
          "$(pipeline_gitBranchName)" &&
            gitRepoResourceName="$(pipeline_detectGitResource)" &&
            [[ -n "$gitRepoResourceName" ]]; then
            function __updateDependencyValidationStatus() {
              echo "not doing the dependency validation status update"
            }
            export -f __updateDependencyValidationStatus
          fi

          stepCommons_on_failure
      onSuccess:
        - >
          if ! common_isReleaseOrMilestoneOrMasterBranch
          "$(pipeline_gitBranchName)" &&
            gitRepoResourceName="$(pipeline_detectGitResource)" &&
            [[ -n "$gitRepoResourceName" ]]; then
            function __updateDependencyValidationStatus() {
              echo "not doing the dependency validation status update"
            }
            export -f __updateDependencyValidationStatus
          fi

          stepCommons_on_success